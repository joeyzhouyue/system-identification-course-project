function [ p2_Rv,p2_theta ] = Zhou_HS2014_SysID_final_p2( p2_u, p2_y,p2_v )
%
%
%
%
%
%
load('final_2014_Prob2.mat');
fprintf(['\nYue Zhou \n','yuezhou@student.ethz.ch\n',...
    'ETH registration: 13-912-472\n\n']);


%% a) Derive the recursive equations for calculating the one-step ahead predictor of the output
% y_hat(kjk  1).

fprintf(['\na)\nWe can use general model structure to analyse the given model \n',...
    'structure. The general predictor is: \n',...
    '                   D(z) * B(z)                D(z)*A(z)\n',...
    'y_hat(k|theta) = ------------- * u(k) + (1 - -----------) * y(k))\n',...
    '                   C(z) * F(z)                 C(z)\n',...
    'In our model the corresponding terms are:\n',...
    'F(z) = 1\n',...
    'D(z) = 1\n',...
    'A(z) = 1 + a1 * z^(-1) + a2 * z^(-2) + a3  * z^(-3) \n',...
    'B(z) = b2 * z^(-2) \n',...
    'C(z) = 1 + c1 * z^(-1) + c2 * z^(-2), from v(k) = e(k) + c1 * e(k-1) + c2 * e(k-2)\n',...
    'So we have : \n',...
    '                  B(z)                A(z)\n',...
    'y_hat(k|theta) = ----- * u(k) + (1 - -----) * y(k))\n',...
    '                  C(z)                C(z)\n',...
    'We can rewrite it to:\n',...
    'y_hat(k|theta) = B(z) * u(k) + (1 - A(z)) * y(k) + (C(z) - 1) * (y(k) - y_hat(k|theta))\n',...
    'Then we take the parameters into the equation, we have:\n',...
    'y_hat(k|theta) = b2*u(k-2) - a1*y(k-1) - a2*y(k-2) - a3y(k-3) + c1*(y(k-1)-y_hat(k-1)) + c2*(y(k-2)-y_hat(k-2))\n',...
    'k = 1,...,N\n',...
    'This is a pseudo-linear recursive equation group with N equations. \n',...
    '\n',...
    ]);

%% b) Based on the available data estimate a 500 * 500 covariance matrix of the signal v(k).
fprintf(['\nb)\nWe want to have a covariance matrix of signal v(k), we could\n',...
    'calculate by using the autocorrelation matrix of v(k). \n',...
    'The relationship between autocovariance and autocorrelation matrix is:\n',...
    '             Cv = Rv - m*m_t \n',...
    'with:\n',...
    'Cv: autocovariance matrix of v(k)\n',...
    'Rv: autocorrelation matrix of v(k)\n',...
    'm, m_t: mean value vector of signal v at each index of time and its transpose\n',...
    'From v(k) = e(k) + c1 * e(k-1) + c2 * e(k-2), we know the mean value of\n',...
    'v should be zeros. So we can calculate autocorrelation and get the\n',...
    'asymptotic covariance matrix, because v is not a periodic signal. \n',...
    'Since v is a random stationary signal, we can calculate the autocorrelation \n',...
    'with the formula: Rx(tau) = E{x(k)x(k-tau)}, tau from -499 to 499. \n']);
fprintf(['But let us do some analysis, after that we can have a much easier\n',...
    'covariance matrix.\n',...
    'At lag = 0,    Rv(0) = E{v(k)v(k)}\n',...
    '                     = E{[e(k)+c1*e(k-1)+c2*e(k-2)]*[e(k)+c1*e(k-1)+c2*e(k-2)]}\n',...
    'because e(k) is white noise signal, so we have now:\n',...
    '                     = E{e(k)^2 + c1^2*e(k-1) + c2^2*e(k-2)}\n',...    
    '                     = (1 + c1*2 + c2*2)E{e(k)^2}\n',...
    'At lag = 1,    Rv(1) = E{v(k)v(k-1)}\n',...
    '                     = E{[e(k)+c1*e(k-1)+c2*e(k-2)]*[e(k-1)+c1*e(k-2)+c2*e(k-3)]}\n',...
    '                     = (c1 + c1*c2)E{e(k)^2}\n',...
    'At lag = 2,    Rv(2) = E{v(k)v(k-2)}\n',...
    '                     = E{[e(k)+c1*e(k-1)+c2*e(k-2)]*[e(k-2)+c1*e(k-3)+c2*e(k-4)]}\n',...
    '                     = c2*E{e(k)^2}\n',...
    'When tau>=3, Rv(tau) = E{v(k)v(k-tau)}\n',...
    '                     = 0\n',...
    'So we just need the autocorrelation values where tau is smaller than 3. \n',...
    'The other values should all be zeros.\n',...
    'So the variance matrix should look like this:\n',...
    '\  ---                                                   ---n',...
    '\  |   x          x          x          0          0     ...| \n',...
    '\  |   x          x          x          x          0     ...| \n',...
    '\  |   x          x          x          x          x     ...| \n',...
    '\  |   0          x          x          x          x     ...| \n',...
    '\  |   0          0          x          x          x     ...| \n',...
    '\  |   ...        ...        ...        ...        ...   ...| \n',...
    '\  ---                                                   ---  \n',...
    'x: the values to be calculated by autocorrelation\n',...
    'Now we have a 500x500 covariance matrix. \n',...
    ]);
Rv = zeros(500,1); 
v_length = length(p2_v); % length of the measured signal data of v 
for tau = 0:499 % because of the symmetry of the autocorrelation, we just 
    % need to calculate the positive values of tau.
    n_auto = v_length - tau; % number of signals of v that are to be calculated 
    % this specific tau.
    v_k_v_k_tau = 0;
    for n_tau = tau + 1 : v_length
        v_k_v_k_tau = v_k_v_k_tau + p2_v(n_tau) * p2_v(n_tau-tau);
    end
    Rv(tau+1) = v_k_v_k_tau / n_auto;
end
p2_Rv = zeros(500); % initialize the covariance matrix
for i = 1 : 500
    for j = 1 : 500
        if abs(i-j)<3
            p2_Rv(i,j) = Rv(abs(i-j) +1);
        end
    end
end

%% c) Calculate an unbiased estimate of the parameters Theta = [ a1 a2 a3 b2] 
% that has the smallest possible variance.

fprintf(['\nc)\nIf we want to have an estimator with the smalles possible variance,\n',...
    'we could use one best linear unbiased estimator(BLUE). But we can not\n',...
    'use the ordinary least squares estimator, because the Gauss-Markov assumptions\n',...
    'are not fulfilled, i.e. the noise is uncorrelated. This is an ARMAX structure \n',...
    'model where the noise has the the same denominator dynamics(in A(z)) as \n',...
    'y. So we can use the generalized least squares estimator with the\n',...
    'known variance matrix of the error,which gives us the unbiased estimate\n',...
    'with the smallest variance.\n',...
    'So we have the model: Y = Phi*Theta + Error, where\n',...
    'Phi:   [Nx4] matrix consisting of predious data, where the k-th rows is \n',...
    '       [-y(k-1) -y(k-2)-y(k-3) u(k-2)]\n',...
    'Theta: [4x1] parameter vector to be determined\n',...
    'Y:     [Nx1] measured output vector\n',...
    'Since the system is assumed to have been started at rest, so we can \n',...
    'use all the data for identification. \n',...
    '\n',...
    '\n',...
    ]);
N = length(p2_u); % data length, here is 500
Phi = zeros(N,4); % Phi matrix containing the measured data
Phi(2,:) = [-p2_y(1) 0        0        0];
Phi(3,:) = [-p2_y(2) -p2_y(1) 0        p2_u(1)];
for i = 4:N
    Phi(i,:) = [-p2_y(i-1) -p2_y(i-2) -p2_y(i-3) p2_u(i-2)];
end
Z = inv(p2_Rv) * Phi*inv(Phi'*inv(p2_Rv)*Phi); % linear estimator
Theta = Z'* p2_y;
p2_theta = Theta;
end

